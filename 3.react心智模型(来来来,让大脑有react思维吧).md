# 人人都能读懂的react源码解析(大厂高薪必备)

## 3.react心智模型(来来来,让大脑有react思维吧)

视频课程&demos

课程结构:

​	在正式开始之前需要了解一下前置知识，现在不太清楚没关系，这些内容会在后面的章节中出现并且详细介绍，这一章的目标是了解react源码中存在的模型(数据结构或者思维)

### react架构

​	react的核心可以用ui=fn(state)来表示，

const state = reconcile(update);
const UI = commit(state);

- Scheduler（调度器）： 排序优先级，让优先级高的任务先进行reconcile

- Reconciler（协调器）： 找出哪些节点发生了改变，并打上不同的Tag

- Renderer（渲染器）： 将Reconciler中打好标签的节点渲染到视图上

  react15没有Scheduler这部分，所以所有任务没有优先级，也不能中断，只能同步执行

### react17的出现是为了解决什么

​	react之前的版本在reconcile的过程中是同步执行的，而在计算复杂组件的差异是一个耗时操作，加之js的执行是单线程的，设备性能不同，页面就会出现卡顿的现象。此外应用所处的网络状况也不同，也需要应对不通网络状态下获取数据的响应，所以为了解决这两类（cpu、io）问题，react17带了全新的concurrent mode，它是一类功能的合集（如fiber、schduler、lane、suspense），其目的是为了提高应用的响应速度，使应用不在那么卡顿，其核心是实现了一套异步可中断、带优先级的更新。

​	那么react17怎么实现异步可中断的更新呢，我们知道一般浏览器的fps是60Hz，也就是每16.6ms会刷新一次，而js执行现成和GUI也就是浏览器的绘制是互斥的，因为js可以操作dom，影响最后呈现的结果，所以如果js执行的时间过长，会导致浏览器没时间绘制dom，造成卡顿。react17会在每一帧中会分配一个时间（时间片）给js执行，如果在这个时间内js还没执行完，那就要暂停它的执行，等下一帧继续执行，把执行权交回给浏览器去绘制。

​	对比下开启和未开启concurrent mode的区别，开启之后，构建Fiber的任务的执行不会一致处于阻塞状态，而是分成了一个个的task



Fiber双缓存

Reconciler

​	协调器是在render阶段工作的，这部分发生在内存中，简单一句话概括就是Reconciler会创建或者更新Fiber节点。在mount的时候会根据jsx生成Fiber对象，在update的时候会根据最新的state形成的jsx对象和current Fiber树对比构建workInProgress Fiber树，这个对比的过程就是diff算法。reconcile时会在这些Fiber上打上Tag标签，在commit阶段吧这些标签应用到真实dom上，这些标签代表节点的增删改，如

```js
export const Placement = /*             */ 0b0000000000010;
export const Update = /*                */ 0b0000000000100;
export const PlacementAndUpdate = /*    */ 0b0000000000110;
export const Deletion = /*              */ 0b0000000001000;
```

### Renderer

​	Renderer是在commit阶段工作的，commit阶段会执行一些声明周期和真实dom节点的操作，不同平台对应的Renderer不同，浏览器对应的就是react-dom。



diff算法

Scheduler：

​	我们知道了要实现异步可中断的更新，需要浏览器指定一个时间，如果没有时间剩余了就需要暂停任务，requestIdleCallback貌似是个不错的选择，但是它存在兼容和触发不稳定的原因，react17中采用MessageChannel来实现。

```js
function workLoopConcurrent() {
  while (workInProgress !== null && !shouldYield()) {//shouldYield判断是否暂停任务
    workInProgress = performUnitOfWork(workInProgress); 
  }
}
```

​	在Scheduler中的每的每个任务的优先级使用过期时间表示的，如果一个任务的过期时间离现在很近，说明它马上就要过期了，优先级很高，如果过期时间很长，那它的优先级就低，没有过期的任务存放在timerQueue中，过期的任务存放在taskQueue中，timerQueue和timerQueue都是小顶堆，所以peek取出来的都是离现在时间最近也就是优先级最高的那个任务，然后优先执行它。

Lane







### jsx

​	jsx是ClassComponent函数或者FunctionComponent的返回值，可以用来表示组件的内容，在经过babel编译之后，最后会被编译成`React.createElement`，这就是为什么jsx文件要声明`import React from 'react'`的原因，你可以在 <a name="https://babeljs.io/repl">babel编译jsx</a> 站点查看jsx被编译后的结果

​	`React.createElement`的源码中做了如下几件事

- 处理config，把除了保留属性外的其他config赋值给props
- 把children处理后赋值给props.children
- 处理defaultProps
- 调用ReactElement返回一个jsx对象

```jsx
export function createElement(type, config, children) {
  let propName;

  const props = {};

  let key = null;
  let ref = null;
  let self = null;
  let source = null;

  if (config != null) {
    //处理config，把除了保留属性外的其他config赋值给props
    //...
  }

  const childrenLength = arguments.length - 2;
  //把children处理后赋值给props.children
  //...

  //处理defaultProps
  //...

  return ReactElement(
    type,
    key,
    ref,
    self,
    source,
    ReactCurrentOwner.current,
    props,
  );
}

const ReactElement = function(type, key, ref, self, source, owner, props) {
  const element = {
    $$typeof: REACT_ELEMENT_TYPE,//表示是ReactElement类型

    type: type,//class或function
    key: key,//key
    ref: ref,//useRef的ref对象
    props: props,//props
    _owner: owner,
  };

  return element;
};

```

​	$$typeof表示的是组件的类型，例如在源码中有一个检查是否是合法Element的函数，就是根object.$$typeof === REACT_ELEMENT_TYPE来判断的

```js
export function isValidElement(object) {
  return (
    typeof object === 'object' &&
    object !== null &&
    object.$$typeof === REACT_ELEMENT_TYPE
  );
}
```

​	如果组建是ClassComponent则type是class本身，如果组件是FunctionComponent创建的，则type是这个function，源码中用ClassComponent.prototype.isReactComponent来区别二者。注意class或者function创建的组件一定要首字母大写，不然后被当成普通节点，type就是字符串。

​	jsx对象上没有优先级、状态、effectTag等标记，这些标记在Fiber对象上，在mount是Fiber根据jix对象来构建，在update是根据最新状态的jsx和current Fiber对比，形成新的workInProgress Fiber，最后workInProgress Fiber切换成current Fiber

![_9](/Users/allenchen/Desktop/文章/人人都能读懂的react源码解析(大厂高薪必备)/_9.jpg)