# äººäººéƒ½èƒ½è¯»æ‡‚çš„reactæºç è§£æ(å¤§å‚é«˜è–ªå¿…å¤‡)

## legacy&concurrent Mode(ä»å…¥å£å¼€å§‹,ç„¶åè®©æˆ‘ä»¬å¥”å‘æœªæ¥)

**è§†é¢‘è¯¾ç¨‹&åœ¨çº¿demosï¼š**

**å¾€æœŸæ–‡ç« :**

1. <a>å¼€ç¯‡(å¬è¯´ä½ è¿˜åœ¨è‰°éš¾çš„å•ƒreactæºç )</a>
2. <a>å¸¦ä¸Šé—®é¢˜å­¦ä¹ (å°‘å¹´,å†™äº†è¿™ä¹ˆå¤šå¹´reactè¿™äº›é—®é¢˜çœŸçš„æ¸…æ¥šäº†å—)</a>
3. <a>reactå¿ƒæ™ºæ¨¡å‹(æ¥æ¥æ¥,è®©å¤§è„‘æœ‰reactæ€ç»´å§)</a>
4. <a>reactæºç å…¨å±€æ¦‚è§ˆ(ç»™ä½ ä¸€å¼ reactæºç åœ°å›¾)</a>
5. <a>legacy&concurrent Mode(ä»å…¥å£å¼€å§‹,ç„¶åè®©æˆ‘ä»¬å¥”å‘æœªæ¥)</a>
6. <a>renderé˜¶æ®µ(å‰å®³äº†,æˆ‘æœ‰åˆ›å»ºFiberçš„æŠ€èƒ½)</a>
7. <a>commité˜¶æ®µ(å¬è¯´renderå¸®æˆ‘ä»¬æ‰“å¥½æ ‡è®°äº†,æ˜ å°„çœŸå®èŠ‚ç‚¹å§)</a>
8. <a>Fiber(æˆ‘æ˜¯åœ¨å†…å­˜ä¸­çš„dom)</a>
9. <a>diffç®—æ³•(å¦ˆå¦ˆå†ä¹Ÿä¸æ‹…å¿ƒæˆ‘çš„diffé¢è¯•äº†)</a>
10. <a>stateæ›´æ–°æµç¨‹(setStateé‡Œåˆ°åº•å‘ç”Ÿäº†ä»€ä¹ˆ)</a>
11. <a>hooksæºç å’Œå®ç°(çœ‹å®˜æ–¹hooksæ–‡æ¡£æ˜¯ä¸æ˜¯å¾ˆæ‡µé€¼)</a>
12. <a>scheduler&laneæ¨¡å‹(æ¥çœ‹çœ‹reactæ˜¯æ€ä¹ˆæ’é˜Ÿçš„)</a>
13. <a>batchedUpdate(reactæ‰¹æ›´æ–°æ˜¯æ€ä¹ˆåšåˆ°çš„å‘¢)</a>
14. <a>suspense(å…ˆæŒ‚ä¼šæœº,ç­‰ä¼šå°±å›æ¥)</a>
15. <a>done(æ€»ç»“&å›ç­”ä¸‹ç¬¬2ç« é—®é¢˜å§)</a>



â€‹	åœ¨å‰é¢çš„è¯¾ç¨‹ä¸­æˆ‘ä»¬å·²ç»å­¦ä¹ äº†reactçš„æ•´ä½“å·¥ä½œæµç¨‹ï¼Œå¯¹å„ä¸ªæµç¨‹åšçš„äº‹æƒ…ä¹Ÿæœ‰äº†å¤§è‡´çš„è®¤è¯†ï¼Œç°åœ¨è®©æˆ‘ä»¬ä»reactçš„å…¥å£å¼€å§‹å­¦ä¹ å„ä¸ªéƒ¨åˆ†çš„æºç å§ã€‚


### reactä¸­å…¥å£å‡½æ•°çš„æ¨¡å¼

é¦–å…ˆï¼Œreactæœ‰å¤šç§æ¨¡å¼è¿›å…¥ä¸»é¢˜å‡½æ•°çš„å…¥å£ï¼Œæˆ‘ä»¬å¯ä»¥ä» reactå®˜æ–¹æ–‡æ¡£<a href="https://zh-hans.reactjs.org/docs/concurrent-mode-adoption.html#feature-comparison">ä½¿ç”¨ Concurrent æ¨¡å¼ï¼ˆå®éªŒæ€§ï¼‰</a>ä¸­å¯¹æ¯”ä¸‰ç§æ¨¡å¼

- **legacy æ¨¡å¼ï¼š** `ReactDOM.render(<App />, rootNode)`ã€‚è¿™æ˜¯å½“å‰ React app ä½¿ç”¨çš„æ–¹å¼ã€‚å½“å‰æ²¡æœ‰è®¡åˆ’åˆ é™¤æœ¬æ¨¡å¼ï¼Œä½†æ˜¯è¿™ä¸ªæ¨¡å¼å¯èƒ½ä¸æ”¯æŒè¿™äº›æ–°åŠŸèƒ½ã€‚
- **blocking æ¨¡å¼ï¼š** `ReactDOM.createBlockingRoot(rootNode).render(<App />)`ã€‚ç›®å‰æ­£åœ¨å®éªŒä¸­ã€‚ä½œä¸ºè¿ç§»åˆ° concurrent æ¨¡å¼çš„ç¬¬ä¸€ä¸ªæ­¥éª¤ã€‚
- **concurrent æ¨¡å¼ï¼š** `ReactDOM.createRoot(rootNode).render(<App />)`ã€‚ç›®å‰åœ¨å®éªŒä¸­ï¼Œæœªæ¥ç¨³å®šä¹‹åï¼Œæ‰“ç®—ä½œä¸º React çš„é»˜è®¤å¼€å‘æ¨¡å¼ã€‚è¿™ä¸ªæ¨¡å¼å¼€å¯äº†*æ‰€æœ‰çš„*æ–°åŠŸèƒ½ã€‚

**ç‰¹æ€§å¯¹æ¯”ï¼š**


|   | legacy æ¨¡å¼ | blocking æ¨¡å¼ | concurrent æ¨¡å¼ |
| - | - | - | - |
| [String Refs](https://zh-hans.reactjs.org/docs/refs-and-the-dom.html#legacy-api-string-refs) | âœ… | ğŸš«** | ğŸš«** |
| [Legacy Context](https://zh-hans.reactjs.org/docs/legacy-context.html) | âœ… | ğŸš«** | ğŸš«** |
| [findDOMNode](https://zh-hans.reactjs.org/docs/strict-mode.html#warning-about-deprecated-finddomnode-usage) | âœ… | ğŸš«** | ğŸš«** |
| [Suspense](https://zh-hans.reactjs.org/docs/concurrent-mode-suspense.html#what-is-suspense-exactly) | âœ… | âœ… | âœ… |
| [SuspenseList](https://zh-hans.reactjs.org/docs/concurrent-mode-patterns.html#suspenselist) | ğŸš« | âœ… | âœ… |
| Suspense SSR + Hydration | ğŸš« | âœ… | âœ… |
| Progressive Hydration | ğŸš« | âœ… | âœ… |
| Selective Hydration | ğŸš« | ğŸš« | âœ… |
| Cooperative Multitasking | ğŸš« | ğŸš« | âœ… |
| Automatic batching of multiple setStates | ğŸš«* | âœ… | âœ… |
| [Priority-based Rendering](https://zh-hans.reactjs.org/docs/concurrent-mode-patterns.html#splitting-high-and-low-priority-state) | ğŸš« | ğŸš« | âœ… |
| [Interruptible Prerendering](https://zh-hans.reactjs.org/docs/concurrent-mode-intro.html#interruptible-rendering) | ğŸš« | ğŸš« | âœ… |
| [useTransition](https://zh-hans.reactjs.org/docs/concurrent-mode-patterns.html#transitions) | ğŸš« | ğŸš« | âœ… |
| [useDeferredValue](https://zh-hans.reactjs.org/docs/concurrent-mode-patterns.html#deferring-a-value) | ğŸš« | ğŸš« | âœ… |
| [Suspense Reveal â€œTrainâ€](https://zh-hans.reactjs.org/docs/concurrent-mode-patterns.html#suspense-reveal-train) | ğŸš« | ğŸš« | âœ… |

*ï¼šlegacy æ¨¡å¼åœ¨åˆæˆäº‹ä»¶ä¸­æœ‰è‡ªåŠ¨æ‰¹å¤„ç†çš„åŠŸèƒ½ï¼Œä½†ä»…é™äºä¸€ä¸ªæµè§ˆå™¨ä»»åŠ¡ã€‚é React äº‹ä»¶æƒ³ä½¿ç”¨è¿™ä¸ªåŠŸèƒ½å¿…é¡»ä½¿ç”¨ `unstable_batchedUpdates`ã€‚åœ¨ blocking æ¨¡å¼å’Œ concurrent æ¨¡å¼ä¸‹ï¼Œæ‰€æœ‰çš„ `setState` åœ¨é»˜è®¤æƒ…å†µä¸‹éƒ½æ˜¯æ‰¹å¤„ç†çš„ã€‚

**ï¼šä¼šåœ¨å¼€å‘ä¸­å‘å‡ºè­¦å‘Šã€‚

### æ¨¡å¼åœ¨reactè¿è¡Œæ—¶çš„å«ä¹‰

â€‹	legacyæ¨¡å¼æ˜¯æˆ‘ä»¬å¸¸ç”¨çš„ï¼Œå®ƒæ„å»ºdomçš„è¿‡ç¨‹æ˜¯åŒæ­¥çš„ï¼Œæ‰€ä»¥åœ¨renderçš„reconcilerä¸­ï¼Œå¦‚æœdiffçš„è¿‡ç¨‹ç‰¹åˆ«è€—æ—¶ï¼Œé‚£ä¹ˆå¯¼è‡´çš„ç»“æœå°±æ˜¯jsä¸€ç›´é˜»å¡é«˜ä¼˜å…ˆçº§çš„ä»»åŠ¡(ä¾‹å¦‚ç”¨æˆ·çš„ç‚¹å‡»äº‹ä»¶)ï¼Œè¡¨ç°ä¸ºé¡µé¢çš„å¡é¡¿ï¼Œæ— æ³•å“åº”ã€‚

â€‹	concurrent Modeæ˜¯reactæœªæ¥çš„æ¨¡å¼ï¼Œå®ƒç”¨æ—¶é—´ç‰‡è°ƒåº¦å®ç°äº†å¼‚æ­¥å¯ä¸­æ–­çš„ä»»åŠ¡ï¼Œæ ¹æ®è®¾å¤‡æ€§èƒ½çš„ä¸åŒï¼Œæ—¶é—´ç‰‡çš„é•¿åº¦ä¹Ÿä¸ä¸€æ ·ï¼Œåœ¨æ¯ä¸ªæ—¶é—´ç‰‡ä¸­ï¼Œå¦‚æœä»»åŠ¡åˆ°äº†è¿‡æœŸæ—¶é—´ï¼Œå°±ä¼šä¸»åŠ¨è®©å‡ºçº¿ç¨‹ç»™é«˜ä¼˜å…ˆçº§çš„ä»»åŠ¡ã€‚è¿™éƒ¨åˆ†å°†åœ¨ç¬¬11èŠ‚ scheduler&laneæ¨¡å‹(æ¥çœ‹çœ‹reactæ˜¯æš‚åœã€ç»§ç»­å’Œæ’é˜Ÿçš„) è¿™ç« ä¼šå…·ä½“è®²è§£reactæ˜¯å¦‚ä½•å®ç°å¼‚æ­¥å¯ä¸­æ–­çš„ä»»åŠ¡ï¼Œä»¥åŠä»»åŠ¡çš„ä¼˜å…ˆçº§å’Œé«˜ä¼˜å…ˆçº§æ˜¯å¦‚æœæ’é˜Ÿçš„ã€‚


### å‡½æ•°è°ƒç”¨çš„é¡ºåºå’Œä½œç”¨

1. ä¸»è¦æµç¨‹ï¼š

   ![_3](/Users/allenchen/Desktop/æ–‡ç« /äººäººèƒ½è¯»æ‡‚çš„reactæºç è§£æ(å¤§å‚é«˜è–ªå¿…å¤‡)/_3.png)

   - legacyRenderSubtreeIntoContainer: ä¸­å‡½æ•°ä¼šè°ƒç”¨åˆ°createFiberRootåˆ›å»ºfiberRootNode,ç„¶åè°ƒç”¨createHostRootFiberåˆ›å»ºrootFiber

     ![_4](/Users/allenchen/Desktop/æ–‡ç« /äººäººèƒ½è¯»æ‡‚çš„reactæºç è§£æ(å¤§å‚é«˜è–ªå¿…å¤‡)/_4.png)
   - updateContainerï¼šä¼šåˆ›å»ºUpdateå¯¹è±¡æŒ‚åœ¨åˆ°updateQueueçš„ç¯å½¢é“¾è¡¨ä¸Š
   - scheduleUpdateOnFiberï¼šä¼šåˆ¤æ–­å½“å‰çš„æ¨¡å¼è¿›å…¥legacyæ¨¡å¼çš„å…¥å£performSyncWorkOnRootæˆ–è€…concurrentçš„å…¥å£performConcurrentWorkOnRootï¼Œç„¶åè¿›å…¥renderé˜¶æ®µ
   - ç„¶åè¿›å…¥commitRootè¿›å…¥commité˜¶æ®µ
2. è¯¦ç»†å‡½æ•°æ‰§è¡Œè¿‡ç¨‹ï¼š

   ![_2](/Users/allenchen/Desktop/æ–‡ç« /äººäººèƒ½è¯»æ‡‚çš„reactæºç è§£æ(å¤§å‚é«˜è–ªå¿…å¤‡)/_2.png)
3. legacyæ¨¡å¼ï¼š

   - çœ‹æ–­ç‚¹è°ƒè¯•è§†é¢‘ï¼Œè°ƒç”¨è¿‡ç¨‹æ›´æ¸…æ¥šï¼š
   - ä¸»è¦å‡½æ•°æ³¨é‡Šï¼š

   ```js
   function render(element, container, callback) {
     if (!isValidContainer(container)) {//éªŒè¯containeråˆæ³•æ€§
      //...
     }
     //åˆ›å»ºcreateFiberRootå…¥å£
     return legacyRenderSubtreeIntoContainer(null, element, container, false, callback);
   }
   ```

   ```js
   function legacyRenderSubtreeIntoContainer(parentComponent, children, container, forceHydrate, callback) {
     //...
     var root = container._reactRootContainer;
     var fiberRoot;

     if (!root) {
       // mountæ—¶
       root = container._reactRootContainer = legacyCreateRootFromDOMContainer(container, forceHydrate);//åˆ›å»ºrootèŠ‚ç‚¹
       fiberRoot = root._internalRoot;

       if (typeof callback === 'function') {//å¤„ç†å›è°ƒ
         var originalCallback = callback;

         callback = function () {
           var instance = getPublicRootInstance(fiberRoot);
           originalCallback.call(instance);
         };
       } 
   ```


       unbatchedUpdates(function () {
         updateContainer(children, fiberRoot, parentComponent, callback);//åˆ›å»ºupdateå…¥å£
       });
     } else {
       // updateæ—¶
       fiberRoot = root._internalRoot;
    
       if (typeof callback === 'function') {//å¤„ç†å›è°ƒ
         var _originalCallback = callback;
    
         callback = function () {
           var instance = getPublicRootInstance(fiberRoot);
    
           _originalCallback.call(instance);
         };
       } 
    
       updateContainer(children, fiberRoot, parentComponent, callback);
     }
   }
   ```

   ```js
   function legacyCreateRootFromDOMContainer(container, forceHydrate) {
     //...
     return createLegacyRoot(container, shouldHydrate ? {//åŒºåˆ†ssr
       hydrate: true
     } : undefined);
   }
   ```

   ```js
   function createRootImpl(container, tag, options) {
    	//...
     var root = createContainer(container, tag, hydrate);//åˆ›å»ºroot
     //...
     return root;
   }
   ```

   ```js
   function createFiberRoot(containerInfo, tag, hydrate, hydrationCallbacks) {
     var root = new FiberRootNode(containerInfo, tag, hydrate);//åˆ›å»ºrootå®ä¾‹
   		//...
     return root;
   }
   ```

   ```js
   function updateContainer(element, container, parentComponent, callback) {
     var lane = requestUpdateLane(current$1);//è·å–å½“å‰å¯ç”¨lane åœ¨12ç« è®²è§£
     var update = createUpdate(eventTime, lane); //åˆ›å»ºupdate

     update.payload = {
       element: element//jsx
     };

     enqueueUpdate(current$1, update);//updateå…¥é˜Ÿ
     scheduleUpdateOnFiber(current$1, lane, eventTime);//è°ƒåº¦update
     return lane;
   }
   ```

   ```js
   function enqueueUpdate(fiber, update) {
     var updateQueue = fiber.updateQueue;
   	//...
     var sharedQueue = updateQueue.shared;
     var pending = sharedQueue.pending;

     if (pending === null) {
       // ç¬¬ä¸€ä¸ªupdate åˆ›å»ºupdateé˜Ÿåˆ—å½¢æˆç¯
       update.next = update;
     } else {
       update.next = pending.next;
       pending.next = update;
     }
   	//...
     sharedQueue.pending = update;//updateæŒ‚è½½åˆ°pendingä¸Š
   }
   ```

   ```js
   function scheduleUpdateOnFiber(fiber, lane, eventTime) {
     if (lane === SyncLane) {//åŒæ­¥lane å¯¹åº”legacyæ¨¡å¼
       //...
       performSyncWorkOnRoot(root);//renderé˜¶æ®µçš„èµ·ç‚¹ renderåœ¨åœ°6ç« è®²è§£
     } else {//concurrentæ¨¡å¼
       //...
       ensureRootIsScheduled(root, eventTime);//ç¡®ä¿rootè¢«è°ƒåº¦
     } 

   }
   ```
4. concurrentï¼š

   - çœ‹æ–­ç‚¹è°ƒè¯•è§†é¢‘ï¼Œè°ƒç”¨è¿‡ç¨‹æ›´æ¸…æ¥šï¼š
   - ä¸»è¦å‡½æ•°æ³¨é‡Š

     ```js
     function ensureRootIsScheduled(root, currentTime) {
       //...
       var nextLanes = getNextLanes(root, root === workInProgressRoot ? workInProgressRootRenderLanes : NoLanes); //è®¡ç®—nextLanes

       //...

      //å°†laneçš„ä¼˜å…ˆçº§è½¬æ¢æˆschdulerçš„ä¼˜å…ˆçº§
       var schedulerPriorityLevel = lanePriorityToSchedulerPriority(newCallbackPriority);
       //ä»¥schedulerPriorityLevelçš„ä¼˜å…ˆçº§æ‰§è¡ŒperformConcurrentWorkOnRoot ä¹Ÿå°±æ˜¯concurrentæ¨¡å¼çš„èµ·ç‚¹
       newCallbackNode = 	  scheduleCallback(schedulerPriorityLevel,performConcurrentWorkOnRoot.bind(null, root));
     }
     ```
5. ä¸¤ç§æ¨¡å¼çš„ä¸åŒç‚¹ï¼š

   1. createRootImplä¸­ä¼ å…¥çš„ç¬¬äºŒä¸ªå‚æ•°ä¸ä¸€æ · ä¸€ä¸ªæ˜¯LegacyRootä¸€ä¸ªæ˜¯ConcurrentRoot
   2. requestUpdateLaneä¸­è·å–çš„laneä¸åŒ
   3. åœ¨å‡½æ•°scheduleUpdateOnFiberä¸­æ ¹æ®ä¸åŒä¼˜å…ˆçº§è¿›å…¥ä¸åŒåˆ†æ”¯ï¼Œlegacyæ¨¡å¼è¿›å…¥performSyncWorkOnRootï¼Œconcurrentæ¨¡å¼ä¼šå¼‚æ­¥è°ƒåº¦performConcurrentWorkOnRoot

