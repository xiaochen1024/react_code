# äººäººèƒ½è¯»æ‡‚çš„reactæºç è§£æ(å¤§å‚é«˜è–ªå¿…å¤‡)

## legacy&concurrent Mode(ä»å…¥å£å¼€å§‹,ç„¶åè®©æˆ‘ä»¬å¥”å‘æœªæ¥)

â€‹	åœ¨å‰é¢çš„è¯¾ç¨‹ä¸­æˆ‘ä»¬å·²ç»å­¦ä¹ äº†reactçš„æ•´ä½“å·¥ä½œæµç¨‹ï¼Œå¯¹å„ä¸ªæµç¨‹åšçš„äº‹æƒ…ä¹Ÿæœ‰äº†å¤§è‡´çš„è®¤è¯†ï¼Œç°åœ¨è®©æˆ‘ä»¬ä»reactçš„å…¥å£å¼€å§‹å­¦ä¹ å„ä¸ªéƒ¨åˆ†çš„æºç å§ã€‚

### reactä¸­å…¥å£å‡½æ•°çš„æ¨¡å¼

â€‹		é¦–å…ˆï¼Œreactæœ‰å¤šç§æ¨¡å¼è¿›å…¥ä¸»é¢˜å‡½æ•°çš„å…¥å£ï¼Œæˆ‘ä»¬å¯ä»¥ä» reactå®˜æ–¹æ–‡æ¡£ <a href="https://zh-hans.reactjs.org/docs/concurrent-mode-adoption.html#feature-comparison">ä½¿ç”¨ Concurrent æ¨¡å¼ï¼ˆå®éªŒæ€§ï¼‰</a>ä¸­å¯¹æ¯”ä¸‰ç§æ¨¡å¼

- **legacy æ¨¡å¼ï¼š** `ReactDOM.render(<App />, rootNode)`ã€‚è¿™æ˜¯å½“å‰ React app ä½¿ç”¨çš„æ–¹å¼ã€‚å½“å‰æ²¡æœ‰è®¡åˆ’åˆ é™¤æœ¬æ¨¡å¼ï¼Œä½†æ˜¯è¿™ä¸ªæ¨¡å¼å¯èƒ½ä¸æ”¯æŒè¿™äº›æ–°åŠŸèƒ½ã€‚
- **blocking æ¨¡å¼ï¼š** `ReactDOM.createBlockingRoot(rootNode).render(<App />)`ã€‚ç›®å‰æ­£åœ¨å®éªŒä¸­ã€‚ä½œä¸ºè¿ç§»åˆ° concurrent æ¨¡å¼çš„ç¬¬ä¸€ä¸ªæ­¥éª¤ã€‚
- **concurrent æ¨¡å¼ï¼š** `ReactDOM.createRoot(rootNode).render(<App />)`ã€‚ç›®å‰åœ¨å®éªŒä¸­ï¼Œæœªæ¥ç¨³å®šä¹‹åï¼Œæ‰“ç®—ä½œä¸º React çš„é»˜è®¤å¼€å‘æ¨¡å¼ã€‚è¿™ä¸ªæ¨¡å¼å¼€å¯äº†*æ‰€æœ‰çš„*æ–°åŠŸèƒ½ã€‚

**ç‰¹æ€§å¯¹æ¯”ï¼š**

|                                                              | legacy æ¨¡å¼ | blocking æ¨¡å¼ | concurrent æ¨¡å¼ |
| ------------------------------------------------------------ | ----------- | ------------- | --------------- |
| [String Refs](https://zh-hans.reactjs.org/docs/refs-and-the-dom.html#legacy-api-string-refs) | âœ…           | ğŸš«**           | ğŸš«**             |
| [Legacy Context](https://zh-hans.reactjs.org/docs/legacy-context.html) | âœ…           | ğŸš«**           | ğŸš«**             |
| [findDOMNode](https://zh-hans.reactjs.org/docs/strict-mode.html#warning-about-deprecated-finddomnode-usage) | âœ…           | ğŸš«**           | ğŸš«**             |
| [Suspense](https://zh-hans.reactjs.org/docs/concurrent-mode-suspense.html#what-is-suspense-exactly) | âœ…           | âœ…             | âœ…               |
| [SuspenseList](https://zh-hans.reactjs.org/docs/concurrent-mode-patterns.html#suspenselist) | ğŸš«           | âœ…             | âœ…               |
| Suspense SSR + Hydration                                     | ğŸš«           | âœ…             | âœ…               |
| Progressive Hydration                                        | ğŸš«           | âœ…             | âœ…               |
| Selective Hydration                                          | ğŸš«           | ğŸš«             | âœ…               |
| Cooperative Multitasking                                     | ğŸš«           | ğŸš«             | âœ…               |
| Automatic batching of multiple setStates                     | ğŸš«*          | âœ…             | âœ…               |
| [Priority-based Rendering](https://zh-hans.reactjs.org/docs/concurrent-mode-patterns.html#splitting-high-and-low-priority-state) | ğŸš«           | ğŸš«             | âœ…               |
| [Interruptible Prerendering](https://zh-hans.reactjs.org/docs/concurrent-mode-intro.html#interruptible-rendering) | ğŸš«           | ğŸš«             | âœ…               |
| [useTransition](https://zh-hans.reactjs.org/docs/concurrent-mode-patterns.html#transitions) | ğŸš«           | ğŸš«             | âœ…               |
| [useDeferredValue](https://zh-hans.reactjs.org/docs/concurrent-mode-patterns.html#deferring-a-value) | ğŸš«           | ğŸš«             | âœ…               |
| [Suspense Reveal â€œTrainâ€](https://zh-hans.reactjs.org/docs/concurrent-mode-patterns.html#suspense-reveal-train) | ğŸš«           | ğŸš«             | âœ…               |

*ï¼šlegacy æ¨¡å¼åœ¨åˆæˆäº‹ä»¶ä¸­æœ‰è‡ªåŠ¨æ‰¹å¤„ç†çš„åŠŸèƒ½ï¼Œä½†ä»…é™äºä¸€ä¸ªæµè§ˆå™¨ä»»åŠ¡ã€‚é React äº‹ä»¶æƒ³ä½¿ç”¨è¿™ä¸ªåŠŸèƒ½å¿…é¡»ä½¿ç”¨ `unstable_batchedUpdates`ã€‚åœ¨ blocking æ¨¡å¼å’Œ concurrent æ¨¡å¼ä¸‹ï¼Œæ‰€æœ‰çš„ `setState` åœ¨é»˜è®¤æƒ…å†µä¸‹éƒ½æ˜¯æ‰¹å¤„ç†çš„ã€‚

**ï¼šä¼šåœ¨å¼€å‘ä¸­å‘å‡ºè­¦å‘Šã€‚

### æ¨¡å¼åœ¨reactè¿è¡Œæ—¶çš„å«ä¹‰

â€‹	legacyæ¨¡å¼æ˜¯æˆ‘ä»¬å¸¸ç”¨çš„ï¼Œå®ƒæ„å»ºdomçš„è¿‡ç¨‹æ˜¯åŒæ­¥çš„ï¼Œæ‰€ä»¥åœ¨renderçš„reconcilerä¸­ï¼Œå¦‚æœdiffçš„è¿‡ç¨‹ç‰¹åˆ«è€—æ—¶ï¼Œé‚£ä¹ˆå¯¼è‡´çš„ç»“æœå°±æ˜¯jsä¸€ç›´é˜»å¡é«˜ä¼˜å…ˆçº§çš„ä»»åŠ¡(ä¾‹å¦‚ç”¨æˆ·çš„ç‚¹å‡»äº‹ä»¶)ï¼Œè¡¨ç°ä¸ºé¡µé¢çš„å¡é¡¿ï¼Œæ— æ³•å“åº”ã€‚

â€‹	concurrent Modeæ˜¯reactæœªæ¥çš„æ¨¡å¼ï¼Œå®ƒç”¨æ—¶é—´ç‰‡è°ƒåº¦å®ç°äº†å¼‚æ­¥å¯ä¸­æ–­çš„ä»»åŠ¡ï¼Œæ ¹æ®è®¾å¤‡æ€§èƒ½çš„ä¸åŒï¼Œæ—¶é—´ç‰‡çš„é•¿åº¦ä¹Ÿä¸ä¸€æ ·ï¼Œåœ¨æ¯ä¸ªæ—¶é—´ç‰‡ä¸­ï¼Œå¦‚æœä»»åŠ¡åˆ°äº†è¿‡æœŸæ—¶é—´ï¼Œå°±ä¼šä¸»åŠ¨è®©å‡ºçº¿ç¨‹ç»™é«˜ä¼˜å…ˆçº§çš„ä»»åŠ¡ã€‚è¿™éƒ¨åˆ†å°†åœ¨ç¬¬11èŠ‚ scheduler&laneæ¨¡å‹(æ¥çœ‹çœ‹reactæ˜¯æš‚åœã€ç»§ç»­å’Œæ’é˜Ÿçš„) è¿™ç« ä¼šå…·ä½“è®²è§£reactæ˜¯å¦‚ä½•å®ç°å¼‚æ­¥å¯ä¸­æ–­çš„ä»»åŠ¡ï¼Œä»¥åŠä»»åŠ¡çš„ä¼˜å…ˆçº§å’Œé«˜ä¼˜å…ˆçº§æ˜¯å¦‚æœæ’é˜Ÿçš„ã€‚

### 	å‡½æ•°è°ƒç”¨çš„é¡ºåºå’Œä½œç”¨

1. ä¸»è¦æµç¨‹ï¼š

2. è¯¦ç»†å‡½æ•°æ‰§è¡Œè¿‡ç¨‹ï¼š

3. legacyæ¨¡å¼ï¼š

   - çœ‹æ–­ç‚¹è°ƒè¯•è§†é¢‘ï¼Œè°ƒç”¨è¿‡ç¨‹æ›´æ¸…æ¥šï¼š

   - è¯¦ç»†å‡½æ•°è°ƒç”¨è¿‡ç¨‹ï¼š

     render

     â€‹	<!--ç¼©ç´§ä»£è¡¨å‡½æ•°å†…éƒ¨è°ƒç”¨-->

     â€‹	<!--ä¾‹å¦‚å½“å‰æ˜¯renderå†…éƒ¨è°ƒç”¨legacyRenderSubtreeIntoContainer-->

     â€‹	legacyRenderSubtreeIntoContainer

     â€‹		legacyCreateRootFromDOMContainer

     â€‹			createLegacyRoot

     â€‹				new ReactDOMBlockingRoot

     â€‹					createRootImpl

     â€‹						createFiberRoot

     â€‹			updateContainer

     â€‹				enqueueUpdate

     â€‹				scheduleUpdateOnFiber

   - ä¸»è¦å‡½æ•°æ³¨é‡Šï¼š

   ```js
   function render(element, container, callback) {
     if (!isValidContainer(container)) {//éªŒè¯containeråˆæ³•æ€§
      //...
     }
     //åˆ›å»ºcreateFiberRootå…¥å£
     return legacyRenderSubtreeIntoContainer(null, element, container, false, callback);
   }
   ```

   â€‹	

   ```js
   function legacyRenderSubtreeIntoContainer(parentComponent, children, container, forceHydrate, callback) {
     //...
     var root = container._reactRootContainer;
     var fiberRoot;
   
     if (!root) {
       // mountæ—¶
       root = container._reactRootContainer = legacyCreateRootFromDOMContainer(container, forceHydrate);//åˆ›å»ºrootèŠ‚ç‚¹
       fiberRoot = root._internalRoot;
   
       if (typeof callback === 'function') {//å¤„ç†å›è°ƒ
         var originalCallback = callback;
   
         callback = function () {
           var instance = getPublicRootInstance(fiberRoot);
           originalCallback.call(instance);
         };
       } 
   
   
       unbatchedUpdates(function () {
         updateContainer(children, fiberRoot, parentComponent, callback);//åˆ›å»ºupdateå…¥å£
       });
     } else {
       // updateæ—¶
       fiberRoot = root._internalRoot;
   
       if (typeof callback === 'function') {//å¤„ç†å›è°ƒ
         var _originalCallback = callback;
   
         callback = function () {
           var instance = getPublicRootInstance(fiberRoot);
   
           _originalCallback.call(instance);
         };
       } 
       
       updateContainer(children, fiberRoot, parentComponent, callback);
     }
   }
   ```

   â€‹	

   ```js
   function legacyCreateRootFromDOMContainer(container, forceHydrate) {
     //...
     return createLegacyRoot(container, shouldHydrate ? {//åŒºåˆ†ssr
       hydrate: true
     } : undefined);
   }
   ```

   â€‹	

   ```js
   function createRootImpl(container, tag, options) {
    	//...
     var root = createContainer(container, tag, hydrate);//åˆ›å»ºroot
     //...
     return root;
   }
   ```

   â€‹	

   ```js
   function createFiberRoot(containerInfo, tag, hydrate, hydrationCallbacks) {
     var root = new FiberRootNode(containerInfo, tag, hydrate);//åˆ›å»ºrootå®ä¾‹
   		//...
     return root;
   }
   ```

   â€‹	

   ```js
   function updateContainer(element, container, parentComponent, callback) {
     var lane = requestUpdateLane(current$1);//è·å–å½“å‰å¯ç”¨lane åœ¨12ç« è®²è§£
     var update = createUpdate(eventTime, lane); //åˆ›å»ºupdate
   
     update.payload = {
       element: element//jsx
     };
   
     enqueueUpdate(current$1, update);//updateå…¥é˜Ÿ
     scheduleUpdateOnFiber(current$1, lane, eventTime);//è°ƒåº¦update
     return lane;
   }
   ```

   â€‹	

   ```js
   function enqueueUpdate(fiber, update) {
     var updateQueue = fiber.updateQueue;
   	//...
     var sharedQueue = updateQueue.shared;
     var pending = sharedQueue.pending;
   
     if (pending === null) {
       // ç¬¬ä¸€ä¸ªupdate åˆ›å»ºupdateé˜Ÿåˆ—å½¢æˆç¯
       update.next = update;
     } else {
       update.next = pending.next;
       pending.next = update;
     }
   	//...
     sharedQueue.pending = update;//updateæŒ‚è½½åˆ°pendingä¸Š
   }
   ```

   â€‹	

   ```js
   function scheduleUpdateOnFiber(fiber, lane, eventTime) {
     if (lane === SyncLane) {//åŒæ­¥lane å¯¹åº”legacyæ¨¡å¼
       //...
       performSyncWorkOnRoot(root);//renderé˜¶æ®µçš„èµ·ç‚¹ renderåœ¨åœ°6ç« è®²è§£
     } else {//concurrentæ¨¡å¼
       //...
       ensureRootIsScheduled(root, eventTime);//ç¡®ä¿rootè¢«è°ƒåº¦
     } 
   
   }
   ```

   

4. concurrentï¼š

   - çœ‹æ–­ç‚¹è°ƒè¯•è§†é¢‘ï¼Œè°ƒç”¨è¿‡ç¨‹æ›´æ¸…æ¥šï¼š

   - è¯¦ç»†å‡½æ•°æ‰§è¡Œè¿‡ç¨‹ï¼š

     createRoot

     â€‹	createRootImpl//åé¢çš„æµç¨‹å’Œlegacyè°ƒç”¨é¡ºåºä¸€æ ·

     ReactDOMRoot.prototype.render

     â€‹	updateContainer/åé¢çš„æµç¨‹å’Œlegacyæ¨¡å¼ä¸€æ ·

   - ä¸»è¦å‡½æ•°æ³¨é‡Š

     ```js
     function ensureRootIsScheduled(root, currentTime) {
       //...
       var nextLanes = getNextLanes(root, root === workInProgressRoot ? workInProgressRootRenderLanes : NoLanes); //è®¡ç®—nextLanes
     
       //...
     
      //å°†laneçš„ä¼˜å…ˆçº§è½¬æ¢æˆschdulerçš„ä¼˜å…ˆçº§
       var schedulerPriorityLevel = lanePriorityToSchedulerPriority(newCallbackPriority);
       //ä»¥schedulerPriorityLevelçš„ä¼˜å…ˆçº§æ‰§è¡ŒperformConcurrentWorkOnRoot ä¹Ÿå°±æ˜¯concurrentæ¨¡å¼çš„èµ·ç‚¹
       newCallbackNode = 	  scheduleCallback(schedulerPriorityLevel,performConcurrentWorkOnRoot.bind(null, root));
     }
     ```

     

5. ä¸¤ç§æ¨¡å¼çš„ä¸åŒç‚¹ï¼š

   1. createRootImplä¸­ä¼ å…¥çš„ç¬¬äºŒä¸ªå‚æ•°ä¸ä¸€æ · ä¸€ä¸ªæ˜¯LegacyRootä¸€ä¸ªæ˜¯ConcurrentRoot
   2. requestUpdateLaneä¸­è·å–çš„laneä¸åŒ
   3. åœ¨å‡½æ•°scheduleUpdateOnFiberä¸­æ ¹æ®ä¸åŒä¼˜å…ˆçº§è¿›å…¥ä¸åŒåˆ†æ”¯ï¼Œlegacyæ¨¡å¼è¿›å…¥performSyncWorkOnRootï¼Œconcurrentæ¨¡å¼ä¼šå¼‚æ­¥è°ƒåº¦performConcurrentWorkOnRoot