# 人人能读懂的react源码解析(大厂高薪必备)

## legacy&concurrent Mode(从入口开始,然后让我们奔向未来)

​	在前面的课程中我们已经学习了react的整体工作流程，对各个流程做的事情也有了大致的认识，现在让我们从react的入口开始学习各个部分的源码吧。

### react中入口函数的模式

​		首先，react有多种模式进入主题函数的入口，我们可以从 react官方文档 <a href="https://zh-hans.reactjs.org/docs/concurrent-mode-adoption.html#feature-comparison">使用 Concurrent 模式（实验性）</a>中对比三种模式

- **legacy 模式：** `ReactDOM.render(<App />, rootNode)`。这是当前 React app 使用的方式。当前没有计划删除本模式，但是这个模式可能不支持这些新功能。
- **blocking 模式：** `ReactDOM.createBlockingRoot(rootNode).render(<App />)`。目前正在实验中。作为迁移到 concurrent 模式的第一个步骤。
- **concurrent 模式：** `ReactDOM.createRoot(rootNode).render(<App />)`。目前在实验中，未来稳定之后，打算作为 React 的默认开发模式。这个模式开启了*所有的*新功能。

**特性对比：**

|                                                              | legacy 模式 | blocking 模式 | concurrent 模式 |
| ------------------------------------------------------------ | ----------- | ------------- | --------------- |
| [String Refs](https://zh-hans.reactjs.org/docs/refs-and-the-dom.html#legacy-api-string-refs) | ✅           | 🚫**           | 🚫**             |
| [Legacy Context](https://zh-hans.reactjs.org/docs/legacy-context.html) | ✅           | 🚫**           | 🚫**             |
| [findDOMNode](https://zh-hans.reactjs.org/docs/strict-mode.html#warning-about-deprecated-finddomnode-usage) | ✅           | 🚫**           | 🚫**             |
| [Suspense](https://zh-hans.reactjs.org/docs/concurrent-mode-suspense.html#what-is-suspense-exactly) | ✅           | ✅             | ✅               |
| [SuspenseList](https://zh-hans.reactjs.org/docs/concurrent-mode-patterns.html#suspenselist) | 🚫           | ✅             | ✅               |
| Suspense SSR + Hydration                                     | 🚫           | ✅             | ✅               |
| Progressive Hydration                                        | 🚫           | ✅             | ✅               |
| Selective Hydration                                          | 🚫           | 🚫             | ✅               |
| Cooperative Multitasking                                     | 🚫           | 🚫             | ✅               |
| Automatic batching of multiple setStates                     | 🚫*          | ✅             | ✅               |
| [Priority-based Rendering](https://zh-hans.reactjs.org/docs/concurrent-mode-patterns.html#splitting-high-and-low-priority-state) | 🚫           | 🚫             | ✅               |
| [Interruptible Prerendering](https://zh-hans.reactjs.org/docs/concurrent-mode-intro.html#interruptible-rendering) | 🚫           | 🚫             | ✅               |
| [useTransition](https://zh-hans.reactjs.org/docs/concurrent-mode-patterns.html#transitions) | 🚫           | 🚫             | ✅               |
| [useDeferredValue](https://zh-hans.reactjs.org/docs/concurrent-mode-patterns.html#deferring-a-value) | 🚫           | 🚫             | ✅               |
| [Suspense Reveal “Train”](https://zh-hans.reactjs.org/docs/concurrent-mode-patterns.html#suspense-reveal-train) | 🚫           | 🚫             | ✅               |

*：legacy 模式在合成事件中有自动批处理的功能，但仅限于一个浏览器任务。非 React 事件想使用这个功能必须使用 `unstable_batchedUpdates`。在 blocking 模式和 concurrent 模式下，所有的 `setState` 在默认情况下都是批处理的。

**：会在开发中发出警告。

### 模式在react运行时的含义

​	legacy模式是我们常用的，它构建dom的过程是同步的，所以在render的reconciler中，如果diff的过程特别耗时，那么导致的结果就是js一直阻塞高优先级的任务(例如用户的点击事件)，表现为页面的卡顿，无法响应。

​	concurrent Mode是react未来的模式，它用时间片调度实现了异步可中断的任务，根据设备性能的不同，时间片的长度也不一样，在每个时间片中，如果任务到了过期时间，就会主动让出线程给高优先级的任务。这部分将在第11节 scheduler&lane模型(来看看react是暂停、继续和插队的) 这章会具体讲解react是如何实现异步可中断的任务，以及任务的优先级和高优先级是如果插队的。

### 	函数调用的顺序和作用

1. 主要流程：

2. 详细函数执行过程：

3. legacy模式：

   - 看断点调试视频，调用过程更清楚：

   - 详细函数调用过程：

     render

     ​	<!--缩紧代表函数内部调用-->

     ​	<!--例如当前是render内部调用legacyRenderSubtreeIntoContainer-->

     ​	legacyRenderSubtreeIntoContainer

     ​		legacyCreateRootFromDOMContainer

     ​			createLegacyRoot

     ​				new ReactDOMBlockingRoot

     ​					createRootImpl

     ​						createFiberRoot

     ​			updateContainer

     ​				enqueueUpdate

     ​				scheduleUpdateOnFiber

   - 主要函数注释：

   ```js
   function render(element, container, callback) {
     if (!isValidContainer(container)) {//验证container合法性
      //...
     }
     //创建createFiberRoot入口
     return legacyRenderSubtreeIntoContainer(null, element, container, false, callback);
   }
   ```

   ​	

   ```js
   function legacyRenderSubtreeIntoContainer(parentComponent, children, container, forceHydrate, callback) {
     //...
     var root = container._reactRootContainer;
     var fiberRoot;
   
     if (!root) {
       // mount时
       root = container._reactRootContainer = legacyCreateRootFromDOMContainer(container, forceHydrate);//创建root节点
       fiberRoot = root._internalRoot;
   
       if (typeof callback === 'function') {//处理回调
         var originalCallback = callback;
   
         callback = function () {
           var instance = getPublicRootInstance(fiberRoot);
           originalCallback.call(instance);
         };
       } 
   
   
       unbatchedUpdates(function () {
         updateContainer(children, fiberRoot, parentComponent, callback);//创建update入口
       });
     } else {
       // update时
       fiberRoot = root._internalRoot;
   
       if (typeof callback === 'function') {//处理回调
         var _originalCallback = callback;
   
         callback = function () {
           var instance = getPublicRootInstance(fiberRoot);
   
           _originalCallback.call(instance);
         };
       } 
       
       updateContainer(children, fiberRoot, parentComponent, callback);
     }
   }
   ```

   ​	

   ```js
   function legacyCreateRootFromDOMContainer(container, forceHydrate) {
     //...
     return createLegacyRoot(container, shouldHydrate ? {//区分ssr
       hydrate: true
     } : undefined);
   }
   ```

   ​	

   ```js
   function createRootImpl(container, tag, options) {
    	//...
     var root = createContainer(container, tag, hydrate);//创建root
     //...
     return root;
   }
   ```

   ​	

   ```js
   function createFiberRoot(containerInfo, tag, hydrate, hydrationCallbacks) {
     var root = new FiberRootNode(containerInfo, tag, hydrate);//创建root实例
   		//...
     return root;
   }
   ```

   ​	

   ```js
   function updateContainer(element, container, parentComponent, callback) {
     var lane = requestUpdateLane(current$1);//获取当前可用lane 在12章讲解
     var update = createUpdate(eventTime, lane); //创建update
   
     update.payload = {
       element: element//jsx
     };
   
     enqueueUpdate(current$1, update);//update入队
     scheduleUpdateOnFiber(current$1, lane, eventTime);//调度update
     return lane;
   }
   ```

   ​	

   ```js
   function enqueueUpdate(fiber, update) {
     var updateQueue = fiber.updateQueue;
   	//...
     var sharedQueue = updateQueue.shared;
     var pending = sharedQueue.pending;
   
     if (pending === null) {
       // 第一个update 创建update队列形成环
       update.next = update;
     } else {
       update.next = pending.next;
       pending.next = update;
     }
   	//...
     sharedQueue.pending = update;//update挂载到pending上
   }
   ```

   ​	

   ```js
   function scheduleUpdateOnFiber(fiber, lane, eventTime) {
     if (lane === SyncLane) {//同步lane 对应legacy模式
       //...
       performSyncWorkOnRoot(root);//render阶段的起点 render在地6章讲解
     } else {//concurrent模式
       //...
       ensureRootIsScheduled(root, eventTime);//确保root被调度
     } 
   
   }
   ```

   

4. concurrent：

   - 看断点调试视频，调用过程更清楚：

   - 详细函数执行过程：

     createRoot

     ​	createRootImpl//后面的流程和legacy调用顺序一样

     ReactDOMRoot.prototype.render

     ​	updateContainer/后面的流程和legacy模式一样

   - 主要函数注释

     ```js
     function ensureRootIsScheduled(root, currentTime) {
       //...
       var nextLanes = getNextLanes(root, root === workInProgressRoot ? workInProgressRootRenderLanes : NoLanes); //计算nextLanes
     
       //...
     
      //将lane的优先级转换成schduler的优先级
       var schedulerPriorityLevel = lanePriorityToSchedulerPriority(newCallbackPriority);
       //以schedulerPriorityLevel的优先级执行performConcurrentWorkOnRoot 也就是concurrent模式的起点
       newCallbackNode = 	  scheduleCallback(schedulerPriorityLevel,performConcurrentWorkOnRoot.bind(null, root));
     }
     ```

     

5. 两种模式的不同点：

   1. createRootImpl中传入的第二个参数不一样 一个是LegacyRoot一个是ConcurrentRoot
   2. requestUpdateLane中获取的lane不同
   3. 在函数scheduleUpdateOnFiber中根据不同优先级进入不同分支，legacy模式进入performSyncWorkOnRoot，concurrent模式会异步调度performConcurrentWorkOnRoot